<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Rush</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        body {
            background: linear-gradient(135deg, #0f1b33, #1a2b4a);
            color: white;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 10px;
            width: 100%;
        }

        h1 {
            font-size: 3.5rem;
            margin-bottom: 5px;
            background: linear-gradient(45deg, #4a6ee0, #6c8cd5, #4a6ee0);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 15px rgba(74, 110, 224, 0.3);
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 1.2rem;
            color: #a0b3e0;
            margin-bottom: 15px;
        }

        .game-area {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 30px;
            width: 100%;
        }

        .main-game {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .grid-container {
            position: relative;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(var(--grid-size, 8), 1fr);
            grid-template-rows: repeat(var(--grid-size, 8), 1fr);
            gap: 3px;
            width: min(80vw, 500px);
            height: min(80vw, 500px);
            background-color: #1e2238;
            border: 4px solid #2a2f4a;
            border-radius: 10px;
            padding: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
        }

        .grid-cell {
            background-color: #2d3047;
            border-radius: 5px;
            transition: all 0.2s ease;
            position: relative;
        }

        .grid-cell.filled {
            border-radius: 8px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
        }

        .grid-cell.preview {
            opacity: 0.6;
        }

        .grid-cell.valid-drop {
            background-color: rgba(76, 217, 100, 0.2);
            animation: pulse 1.5s infinite;
        }

        .grid-cell.invalid-drop {
            background-color: rgba(255, 59, 48, 0.2);
        }

        @keyframes pulse {
            0% { background-color: rgba(76, 217, 100, 0.2); }
            50% { background-color: rgba(76, 217, 100, 0.4); }
            100% { background-color: rgba(76, 217, 100, 0.2); }
        }

        .next-pieces {
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-width: 300px;
            max-width: 100%;
        }

        .next-piece {
            background: linear-gradient(145deg, #27293d, #1f2235);
            border: 2px solid #2a2f4a;
            border-radius: 12px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s ease;
            position: relative;
        }

        .next-piece:hover {
            transform: translateY(-5px);
        }

        .next-piece.special::before {
            content: "‚ú®";
            position: absolute;
            top: -10px;
            right: -10px;
            font-size: 1.5rem;
            animation: glow 2s infinite;
        }

        @keyframes glow {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        .next-piece h3 {
            margin-bottom: 10px;
            color: #6c8cd5;
            font-size: 1.3rem;
        }

        .piece-container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100px;
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            background-color: rgba(30, 34, 56, 0.5);
            cursor: grab;
            transition: all 0.2s ease;
        }

        .piece-container:active {
            cursor: grabbing;
        }

        .piece-preview {
            display: grid;
            gap: 3px;
            margin: 5px;
        }

        .piece-cell {
            width: min(4vw, 30px);
            height: min(4vw, 30px);
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .piece-dragging {
            opacity: 0.8;
            transform: scale(1.05);
            z-index: 100;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-width: 300px;
        }

        .controls {
            background: linear-gradient(145deg, #27293d, #1f2235);
            border: 2px solid #2a2f4a;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .controls h3 {
            margin-bottom: 15px;
            color: #6c8cd5;
            text-align: center;
            font-size: 1.5rem;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            text-align: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .stat {
            display: flex;
            flex-direction: column;
            min-width: 80px;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #6c8cd5;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #a0b3e0;
        }

        .game-modes {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .mode-btn {
            flex: 1;
            padding: 10px;
            background: #2d3047;
            border: 2px solid #3d4163;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #4a6ee0, #6c8cd5);
            border-color: #4a6ee0;
        }

        .mode-btn:hover {
            background: #3d4163;
        }

        button {
            padding: 14px 25px;
            background: linear-gradient(135deg, #4a6ee0, #6c8cd5);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
            box-shadow: 0 5px 15px rgba(74, 110, 224, 0.3);
            margin-top: 10px;
        }

        button:hover {
            background: linear-gradient(135deg, #5a7ef0, #7c9ce5);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(74, 110, 224, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: linear-gradient(135deg, #6c757d, #5a6268);
        }

        button.secondary:hover {
            background: linear-gradient(135deg, #7c858d, #6a7278);
        }

        .score-container {
            font-size: 1.8rem;
            margin: 15px 0;
            text-align: center;
            background: rgba(30, 34, 56, 0.7);
            padding: 15px 30px;
            border-radius: 12px;
            border: 2px solid #2a2f4a;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .score {
            font-weight: bold;
            color: #6c8cd5;
            font-size: 2.5rem;
            text-shadow: 0 0 10px rgba(74, 110, 224, 0.5);
        }

        .timer {
            font-size: 1.5rem;
            color: #ffcc00;
            margin-top: 10px;
        }

        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 10px;
            z-index: 100;
            backdrop-filter: blur(5px);
        }

        .game-over h2 {
            font-size: 3.5rem;
            color: #ff4d4d;
            margin-bottom: 20px;
            text-shadow: 0 0 15px rgba(255, 77, 77, 0.5);
        }

        .game-over p {
            font-size: 1.8rem;
            margin-bottom: 30px;
        }

        .instructions {
            margin-top: 20px;
            text-align: center;
            color: #a0b3e0;
            font-size: 1.1rem;
            max-width: 600px;
            line-height: 1.6;
        }

        .color-blue { background: linear-gradient(145deg, #4a6ee0, #3a5ed0); }
        .color-green { background: linear-gradient(145deg, #4cd964, #3cc954); }
        .color-lightblue { background: linear-gradient(145deg, #5ac8fa, #4ab8ea); }
        .color-orange { background: linear-gradient(145deg, #ff9500, #ef8500); }
        .color-purple { background: linear-gradient(145deg, #af52de, #9f42ce); }
        .color-red { background: linear-gradient(145deg, #ff3b30, #ef2b20); }
        .color-yellow { background: linear-gradient(145deg, #ffcc00, #efbc00); }
        .color-black { background: linear-gradient(145deg, #2d3047, #1d2037); }
        .color-rainbow { 
            background: linear-gradient(45deg, #ff0000, #ff9500, #ffcc00, #4cd964, #5ac8fa, #4a6ee0, #af52de);
            animation: rainbow 3s infinite;
        }

        @keyframes rainbow {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }

        .drag-ghost {
            position: absolute;
            pointer-events: none;
            z-index: 1000;
            opacity: 0.8;
        }

        .achievements-panel {
            background: linear-gradient(145deg, #27293d, #1f2235);
            border: 2px solid #2a2f4a;
            border-radius: 12px;
            padding: 20px;
            max-height: 300px;
            overflow-y: auto;
        }

        .achievement {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            margin-bottom: 10px;
            background: rgba(30, 34, 56, 0.5);
            border-radius: 8px;
            transition: all 0.3s;
        }

        .achievement.earned {
            background: linear-gradient(135deg, rgba(76, 217, 100, 0.2), rgba(76, 217, 100, 0.1));
            border-left: 4px solid #4cd964;
        }

        .achievement-icon {
            font-size: 1.5rem;
        }

        .achievement-info {
            flex: 1;
        }

        .achievement-name {
            font-weight: bold;
            color: #6c8cd5;
        }

        .achievement-desc {
            font-size: 0.9rem;
            color: #a0b3e0;
        }

        .challenges-panel {
            background: linear-gradient(145deg, #27293d, #1f2235);
            border: 2px solid #2a2f4a;
            border-radius: 12px;
            padding: 20px;
        }

        .challenge {
            padding: 10px;
            margin-bottom: 10px;
            background: rgba(30, 34, 56, 0.5);
            border-radius: 8px;
        }

        .challenge-progress {
            height: 6px;
            background: #2d3047;
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }

        .challenge-progress-bar {
            height: 100%;
            background: linear-gradient(135deg, #4a6ee0, #6c8cd5);
            border-radius: 3px;
            transition: width 0.3s;
        }

        .skills-panel {
            background: linear-gradient(145deg, #27293d, #1f2235);
            border: 2px solid #2a2f4a;
            border-radius: 12px;
            padding: 20px;
        }

        .skill {
            margin-bottom: 15px;
        }

        .skill-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .skill-bar {
            height: 8px;
            background: #2d3047;
            border-radius: 4px;
            overflow: hidden;
        }

        .skill-progress {
            height: 100%;
            background: linear-gradient(135deg, #4a6ee0, #6c8cd5);
            border-radius: 4px;
            transition: width 0.3s;
        }

        .particle {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 50;
        }

        .floating-text {
            position: absolute;
            font-size: 1.5rem;
            font-weight: bold;
            pointer-events: none;
            z-index: 50;
            animation: floatUp 1s forwards;
        }

        @keyframes floatUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-50px); opacity: 0; }
        }

        .clear-animation {
            animation: clearFlash 0.5s;
        }

        @keyframes clearFlash {
            0% { background-color: rgba(255, 255, 255, 0.8); }
            100% { background-color: transparent; }
        }

        .combo-counter {
            position: absolute;
            font-size: 1.5rem;
            font-weight: bold;
            color: #ffcc00;
            text-shadow: 0 0 10px rgba(255, 204, 0, 0.7);
            animation: floatUp 1s forwards;
            pointer-events: none;
            z-index: 50;
        }

        .tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .tutorial-box {
            background: linear-gradient(145deg, #27293d, #1f2235);
            border: 2px solid #2a2f4a;
            border-radius: 12px;
            padding: 30px;
            max-width: 500px;
            text-align: center;
        }

        .hint-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 204, 0, 0.2);
            border: 2px solid #ffcc00;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #ffcc00;
            font-size: 1.2rem;
        }

        @media (max-width: 768px) {
            .game-area {
                flex-direction: column;
                align-items: center;
            }
            
            .grid {
                width: 90vw;
                height: 90vw;
            }
            
            h1 {
                font-size: 2.5rem;
            }
            
            .next-pieces {
                flex-direction: row;
                justify-content: space-around;
                width: 100%;
            }
            
            .next-piece {
                flex: 1;
                margin: 0 5px;
            }
            
            .piece-cell {
                width: 4vw;
                height: 4vw;
            }
            
            .stats {
                flex-direction: column;
                gap: 15px;
            }

            .sidebar {
                width: 100%;
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 2rem;
            }
            
            .score-container {
                font-size: 1.5rem;
            }
            
            .score {
                font-size: 2rem;
            }
            
            .next-pieces {
                flex-direction: column;
            }
            
            .piece-cell {
                width: 6vw;
                height: 6vw;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Block Rush</h1>
            <div class="subtitle">–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –±–ª–æ–∫–∏ –Ω–∞ –ø–æ–ª–µ, —á—Ç–æ–±—ã –∑–∞–ø–æ–ª–Ω–∏—Ç—å –ª–∏–Ω–∏–∏</div>
            <div class="score-container">
                –°—á–µ—Ç: <span class="score" id="score">0</span>
                <div class="timer" id="timer" style="display: none;"></div>
            </div>
        </header>

        <div class="game-area">
            <div class="main-game">
                <div class="grid-container">
                    <div class="grid" id="grid"></div>
                    <div class="hint-button" id="hintButton" title="–ü–æ–∫–∞–∑–∞—Ç—å –ø–æ–¥—Å–∫–∞–∑–∫—É">üí°</div>
                    <div class="game-over" id="gameOver" style="display: none;">
                        <h2>–ò–≥—Ä–∞ –û–∫–æ–Ω—á–µ–Ω–∞!</h2>
                        <p>–§–∏–Ω–∞–ª—å–Ω—ã–π —Å—á–µ—Ç: <span id="finalScore">0</span></p>
                        <button id="restartButton">–ù–æ–≤–∞—è –ò–≥—Ä–∞</button>
                    </div>
                </div>

                <div class="next-pieces">
                    <div class="next-piece">
                        <h3>–ë–ª–æ–∫ 1</h3>
                        <div class="piece-container" id="pieceContainer1" data-piece="0">
                            <div class="piece-preview" id="piece1"></div>
                        </div>
                    </div>
                    <div class="next-piece">
                        <h3>–ë–ª–æ–∫ 2</h3>
                        <div class="piece-container" id="pieceContainer2" data-piece="1">
                            <div class="piece-preview" id="piece2"></div>
                        </div>
                    </div>
                    <div class="next-piece">
                        <h3>–ë–ª–æ–∫ 3</h3>
                        <div class="piece-container" id="pieceContainer3" data-piece="2">
                            <div class="piece-preview" id="piece3"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="sidebar">
                <div class="controls">
                    <h3>–†–µ–∂–∏–º—ã –∏–≥—Ä—ã</h3>
                    <div class="game-modes">
                        <button class="mode-btn active" data-mode="classic">–ö–ª–∞—Å—Å–∏–∫–∞</button>
                        <button class="mode-btn" data-mode="time">–ù–∞ –≤—Ä–µ–º—è</button>
                        <button class="mode-btn" data-mode="survival">–í—ã–∂–∏–≤–∞–Ω–∏–µ</button>
                    </div>
                    
                    <div class="stats">
                        <div class="stat">
                            <div class="stat-value" id="blocksPlaced">0</div>
                            <div class="stat-label">–ë–ª–æ–∫–æ–≤</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="linesCleared">0</div>
                            <div class="stat-label">–õ–∏–Ω–∏–π</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="combo">0</div>
                            <div class="stat-label">–ö–æ–º–±–æ</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="level">1</div>
                            <div class="stat-label">–£—Ä–æ–≤–µ–Ω—å</div>
                        </div>
                    </div>
                    
                    <button id="rotateButton">–ü–æ–≤–µ—Ä–Ω—É—Ç—å –±–ª–æ–∫</button>
                    <button id="hintBtn">–ü–æ–¥—Å–∫–∞–∑–∫–∞</button>
                    <button id="newGameButton">–ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
                    <button id="soundToggle">üîä –ó–≤—É–∫</button>
                </div>

                <div class="achievements-panel">
                    <h3>–î–æ—Å—Ç–∏–∂–µ–Ω–∏—è</h3>
                    <div id="achievementsList"></div>
                </div>

                <div class="challenges-panel">
                    <h3>–ó–∞–¥–∞–Ω–∏—è</h3>
                    <div id="challengesList"></div>
                </div>

                <div class="skills-panel">
                    <h3>–ù–∞–≤—ã–∫–∏</h3>
                    <div id="skillsList"></div>
                </div>
            </div>
        </div>

        <div class="instructions">
            <p>–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –±–ª–æ–∫–∏ –Ω–∞ –∏–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ. –ó–∞–ø–æ–ª–Ω—è–π—Ç–µ —Ü–µ–ª—ã–µ —Å—Ç—Ä–æ–∫–∏ –∏–ª–∏ —Å—Ç–æ–ª–±—Ü—ã, —á—Ç–æ–±—ã –æ—á–∏—Å—Ç–∏—Ç—å –∏—Ö –∏ –∑–∞—Ä–∞–±–æ—Ç–∞—Ç—å –æ—á–∫–∏!</p>
        </div>
    </div>

    <div id="tutorialOverlay" class="tutorial-overlay" style="display: none;">
        <div class="tutorial-box">
            <h3 id="tutorialTitle">–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ Block Rush!</h3>
            <p id="tutorialText">–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –±–ª–æ–∫ –Ω–∞ –ø–æ–ª–µ —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –∏–≥—Ä—É</p>
            <button id="tutorialNext">–ü–æ–Ω—è—Ç–Ω–æ</button>
        </div>
    </div>

    <script>
        // Game constants
        const GRID_SIZE = 8;
        const NEXT_PIECES_COUNT = 3;
        const COLORS = ['blue', 'green', 'lightblue', 'orange', 'purple', 'red', 'yellow'];

        // Base block shapes
        const BASE_BLOCKS = [
            [[1, 1]],  // 2x1 block
            [[1, 1, 1]],  // 3x1 block
            [[1, 1, 1, 1]],  // 4x1 block
            [[1, 1, 1, 1, 1]],  // 5x1 block
            [[1, 1], [1, 1]],  // 2x2 block
            [[1, 1, 1, 1], [1, 1, 1, 1]],  // 4x2 block
            [[1, 1, 1], [1, 1, 1], [1, 1, 1]],  // 3x3 block
            [[1, 1, 1], [1, 0, 0], [1, 0, 0]],  // 3x3 - 2x2 block
            [[1, 1], [1, 0]],  // 2x2 - 2x1 block
            [[1, 1, 1], [1, 0, 0]],  // Tetris L block
            [[1, 1, 1], [0, 0, 1]],  // Tetris J block
            [[1, 1, 1], [0, 1, 0]],  // Tetris T block
            [[1, 1], [0, 1], [0, 1]],  // Tetris S block
            [[1, 1], [1, 0], [1, 0]],  // Tetris Z block
            [[1, 0], [0, 1]],  // Diagonal 2x2 block
            [[1, 0, 0], [0, 1, 0], [0, 0, 1]],  // Diagonal 3x3 block
        ];

        // Special blocks
        const SPECIAL_BLOCKS = {
            bomb: { 
                shape: [[1]], 
                color: "black", 
                effect: "–û—á–∏—â–∞–µ—Ç –æ–±–ª–∞—Å—Ç—å 3x3 –≤–æ–∫—Ä—É–≥ —Å–µ–±—è",
                onPlace: function(x, y, grid) {
                    for (let i = -1; i <= 1; i++) {
                        for (let j = -1; j <= 1; j++) {
                            if (grid[y+i] && grid[y+i][x+j] !== undefined) {
                                grid[y+i][x+j] = null;
                            }
                        }
                    }
                    return 50; // bonus points
                }
            },
            rainbow: {
                shape: [[1]],
                color: "rainbow", 
                effect: "–û—á–∏—â–∞–µ—Ç –≤—Å–µ –±–ª–æ–∫–∏ –æ–¥–Ω–æ–≥–æ —Å–ª—É—á–∞–π–Ω–æ–≥–æ —Ü–≤–µ—Ç–∞",
                onPlace: function(x, y, grid) {
                    const colors = [...new Set(grid.flat().filter(cell => cell && !['black', 'rainbow'].includes(cell)))];
                    if (colors.length > 0) {
                        const targetColor = colors[Math.floor(Math.random() * colors.length)];
                        let cleared = 0;
                        grid.forEach((row, i) => {
                            row.forEach((cell, j) => {
                                if (cell === targetColor) {
                                    grid[i][j] = null;
                                    cleared++;
                                }
                            });
                        });
                        return cleared * 10;
                    }
                    return 0;
                }
            }
        };

        // Difficulty levels
        const DIFFICULTY_LEVELS = {
            classic: { gridSize: 8, timeLimit: null, requiredScore: null },
            time: { gridSize: 8, timeLimit: 120, requiredScore: 1000 },
            survival: { gridSize: 8, timeLimit: null, requiredScore: null, levelUpBlocks: 10 }
        };

        // Achievements system
        const ACHIEVEMENTS = {
            firstBlood: { 
                name: "–ü–µ—Ä–≤–∞—è –∫—Ä–æ–≤—å", 
                desc: "–†–∞–∑–º–µ—Å—Ç–∏—Ç–µ –ø–µ—Ä–≤—ã–π –±–ª–æ–∫", 
                earned: false,
                icon: "ü©∏"
            },
            lineMaster: { 
                name: "–ú–∞—Å—Ç–µ—Ä –ª–∏–Ω–∏–π", 
                desc: "–û—á–∏—Å—Ç–∏—Ç–µ 10 –ª–∏–Ω–∏–π", 
                earned: false,
                icon: "üìä",
                progress: 0,
                target: 10
            },
            comboKing: { 
                name: "–ö–æ—Ä–æ–ª—å –∫–æ–º–±–æ", 
                desc: "–°–æ–±–µ—Ä–∏—Ç–µ –∫–æ–º–±–æ x5", 
                earned: false,
                icon: "üëë",
                progress: 0,
                target: 5
            },
            perfectionist: { 
                name: "–ü–µ—Ä—Ñ–µ–∫—Ü–∏–æ–Ω–∏—Å—Ç", 
                desc: "–ó–∞–ø–æ–ª–Ω–∏—Ç–µ 90% —Å–µ—Ç–∫–∏", 
                earned: false,
                icon: "‚≠ê",
                progress: 0,
                target: 90
            },
            speedRunner: { 
                name: "–°–ø–∏–¥—Ä–∞–Ω–Ω–µ—Ä", 
                desc: "–ù–∞–±–µ—Ä–∏—Ç–µ 1000 –æ—á–∫–æ–≤ –∑–∞ 2 –º–∏–Ω—É—Ç—ã", 
                earned: false,
                icon: "‚ö°"
            },
            bombExpert: {
                name: "–°–∞–ø–µ—Ä",
                desc: "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ 5 –±–æ–º–±",
                earned: false,
                icon: "üí£",
                progress: 0,
                target: 5
            }
        };

        // Daily challenges
        const DAILY_CHALLENGES = [
            {
                id: 1,
                description: "–û—á–∏—Å—Ç–∏—Ç–µ 5 —Å—Ç—Ä–æ–∫",
                target: 5,
                current: 0,
                reward: 100,
                type: "rows"
            },
            {
                id: 2,
                description: "–°–æ–±–µ—Ä–∏—Ç–µ –∫–æ–º–±–æ x3",
                target: 3,
                current: 0,
                reward: 150,
                type: "combo"
            },
            {
                id: 3,
                description: "–†–∞–∑–º–µ—Å—Ç–∏—Ç–µ 20 –±–ª–æ–∫–æ–≤",
                target: 20,
                current: 0,
                reward: 200,
                type: "blocks"
            }
        ];

        // Skills system
        const SKILLS = {
            precision: {
                level: 1,
                exp: 0,
                expToNext: 100,
                name: "–¢–æ—á–Ω–æ—Å—Ç—å",
                effect: "–£–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç –æ—á–∫–∏ –∑–∞ —Ç–æ—á–Ω–æ–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ",
                calculateBonus: function(score) {
                    return Math.floor(score * (1 + this.level * 0.1));
                }
            },
            strategist: {
                level: 1,
                exp: 0,
                expToNext: 100,
                name: "–°—Ç—Ä–∞—Ç–µ–≥",
                effect: "–£–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç —à–∞–Ω—Å –ø–æ—è–≤–ª–µ–Ω–∏—è —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö –±–ª–æ–∫–æ–≤",
                getSpecialBlockChance: function() {
                    return this.level * 0.03;
                }
            },
            efficiency: {
                level: 1,
                exp: 0,
                expToNext: 100,
                name: "–≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å",
                effect: "–£–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç –æ—á–∫–∏ –∑–∞ –∫–æ–º–±–æ",
                getComboMultiplier: function(baseMultiplier) {
                    return baseMultiplier + (this.level * 0.1);
                }
            }
        };

        // Tutorial steps
        const TUTORIAL_STEPS = [
            {
                title: "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ Block Rush!",
                text: "–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –±–ª–æ–∫ –Ω–∞ –ø–æ–ª–µ —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –∏–≥—Ä—É",
                highlight: ".piece-container"
            },
            {
                title: "–ó–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –ª–∏–Ω–∏–π",
                text: "–ó–∞–ø–æ–ª–Ω—è–π—Ç–µ —Ü–µ–ª—ã–µ —Å—Ç—Ä–æ–∫–∏ –∏–ª–∏ —Å—Ç–æ–ª–±—Ü—ã —á—Ç–æ–±—ã –æ—á–∏—Å—Ç–∏—Ç—å –∏—Ö –∏ –∑–∞—Ä–∞–±–æ—Ç–∞—Ç—å –æ—á–∫–∏",
                highlight: ".grid"
            },
            {
                title: "–ü–æ–≤–æ—Ä–æ—Ç –±–ª–æ–∫–æ–≤",
                text: "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫—É '–ü–æ–≤–µ—Ä–Ω—É—Ç—å –±–ª–æ–∫' –¥–ª—è –ª—É—á—à–µ–≥–æ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è",
                highlight: "#rotateButton"
            },
            {
                title: "–°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ –±–ª–æ–∫–∏",
                text: "–ò–Ω–æ–≥–¥–∞ –ø–æ—è–≤–ª—è—é—Ç—Å—è —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ –±–ª–æ–∫–∏ —Å –æ—Å–æ–±—ã–º–∏ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—è–º–∏",
                highlight: ".next-piece.special"
            }
        ];

        // Game state
        let grid = [];
        let nextPieces = [];
        let score = 0;
        let gameOver = false;
        let blocksPlaced = 0;
        let linesCleared = 0;
        let maxCombo = 0;
        let currentCombo = 0;
        let selectedPieceIndex = null;
        let dragGhost = null;
        let currentMode = 'classic';
        let gameLevel = 1;
        let timeLeft = 0;
        let gameTimer = null;
        let survivalBlocksPlaced = 0;
        let audioManager = null;
        let comboSystem = null;
        let playerStats = null;
        let tutorialStep = 0;
        let specialBlockChance = 0.1;

        // DOM elements
        const gridElement = document.getElementById('grid');
        const scoreElement = document.getElementById('score');
        const gameOverElement = document.getElementById('gameOver');
        const finalScoreElement = document.getElementById('finalScore');
        const restartButton = document.getElementById('restartButton');
        const newGameButton = document.getElementById('newGameButton');
        const rotateButton = document.getElementById('rotateButton');
        const hintButton = document.getElementById('hintButton');
        const hintBtn = document.getElementById('hintBtn');
        const soundToggle = document.getElementById('soundToggle');
        const blocksPlacedElement = document.getElementById('blocksPlaced');
        const linesClearedElement = document.getElementById('linesCleared');
        const comboElement = document.getElementById('combo');
        const levelElement = document.getElementById('level');
        const timerElement = document.getElementById('timer');
        const achievementsList = document.getElementById('achievementsList');
        const challengesList = document.getElementById('challengesList');
        const skillsList = document.getElementById('skillsList');
        const tutorialOverlay = document.getElementById('tutorialOverlay');
        const tutorialTitle = document.getElementById('tutorialTitle');
        const tutorialText = document.getElementById('tutorialText');
        const tutorialNext = document.getElementById('tutorialNext');
        const modeButtons = document.querySelectorAll('.mode-btn');

        // Audio Manager
        class AudioManager {
            constructor() {
                this.sounds = {
                    place: this.createSound(400, 0.2),
                    clear: this.createSound(600, 0.3),
                    rotate: this.createSound(300, 0.2),
                    gameOver: this.createSound(200, 0.4),
                    combo: this.createSound(800, 0.3),
                    achievement: this.createSound(1000, 0.4)
                };
                this.muted = false;
            }
            
            createSound(frequency, duration) {
                return { frequency, duration };
            }
            
            play(soundName) {
                if (this.muted || !this.sounds[soundName]) return;
                
                const sound = this.sounds[soundName];
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = sound.frequency;
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + sound.duration);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + sound.duration);
                } catch (e) {
                    console.log('Audio not supported');
                }
            }
            
            toggleMute() {
                this.muted = !this.muted;
                soundToggle.textContent = this.muted ? "üîá –ó–≤—É–∫" : "üîä –ó–≤—É–∫";
            }
        }

        // Combo System
        class ComboSystem {
            constructor() {
                this.currentCombo = 0;
                this.multiplier = 1;
                this.comboTimer = null;
                this.comboTimeLimit = 3000;
            }
            
            startCombo() {
                this.currentCombo++;
                this.multiplier = 1 + Math.floor(this.currentCombo / 3);
                
                clearTimeout(this.comboTimer);
                this.comboTimer = setTimeout(() => {
                    this.resetCombo();
                }, this.comboTimeLimit);
                
                this.showComboEffects();
                this.updateAchievement('comboKing', this.currentCombo);
                
                return this.multiplier;
            }
            
            resetCombo() {
                if (this.currentCombo > maxCombo) {
                    maxCombo = this.currentCombo;
                    comboElement.textContent = maxCombo;
                }
                this.currentCombo = 0;
                this.multiplier = 1;
            }
            
            showComboEffects() {
                if (this.currentCombo >= 3) {
                    document.body.style.filter = `hue-rotate(${this.currentCombo * 10}deg)`;
                    setTimeout(() => {
                        document.body.style.filter = 'none';
                    }, 500);
                }
            }
        }

        // Player Statistics
        class PlayerStats {
            constructor() {
                this.totalGames = 0;
                this.totalScore = 0;
                this.bestScore = 0;
                this.averageScore = 0;
                this.blocksPlaced = 0;
                this.linesCleared = 0;
                this.maxCombo = 0;
                this.playTime = 0;
                this.achievementsEarned = 0;
                this.specialBlocksUsed = 0;
                
                this.loadFromLocalStorage();
            }
            
            updateStats(gameResult) {
                this.totalGames++;
                this.totalScore += gameResult.score;
                this.bestScore = Math.max(this.bestScore, gameResult.score);
                this.averageScore = Math.round(this.totalScore / this.totalGames);
                this.blocksPlaced += gameResult.blocksPlaced;
                this.linesCleared += gameResult.linesCleared;
                this.maxCombo = Math.max(this.maxCombo, gameResult.maxCombo);
                this.playTime += gameResult.playTime;
                
                this.saveToLocalStorage();
            }
            
            saveToLocalStorage() {
                localStorage.setItem('blockRushStats', JSON.stringify(this));
            }
            
            loadFromLocalStorage() {
                const saved = localStorage.getItem('blockRushStats');
                if (saved) {
                    const data = JSON.parse(saved);
                    Object.assign(this, data);
                }
            }
        }

        // Initialize the game
        function initGame() {
            // Initialize systems
            audioManager = new AudioManager();
            comboSystem = new ComboSystem();
            playerStats = new PlayerStats();
            
            // Initialize grid
            const gridSize = DIFFICULTY_LEVELS[currentMode].gridSize;
            grid = Array(gridSize).fill().map(() => Array(gridSize).fill(null));
            gridElement.style.setProperty('--grid-size', gridSize);
            
            // Initialize next pieces
            nextPieces = [];
            for (let i = 0; i < NEXT_PIECES_COUNT; i++) {
                nextPieces.push(generatePiece());
            }
            
            // Reset game state
            score = 0;
            gameOver = false;
            blocksPlaced = 0;
            linesCleared = 0;
            maxCombo = 0;
            currentCombo = 0;
            gameLevel = 1;
            survivalBlocksPlaced = 0;
            selectedPieceIndex = null;
            
            // Update UI
            scoreElement.textContent = score;
            blocksPlacedElement.textContent = blocksPlaced;
            linesClearedElement.textContent = linesCleared;
            comboElement.textContent = maxCombo;
            levelElement.textContent = gameLevel;
            gameOverElement.style.display = 'none';
            
            // Setup game mode
            setupGameMode();
            
            // Render initial state
            renderGrid();
            renderNextPieces();
            renderAchievements();
            renderChallenges();
            renderSkills();
            
            // Setup event listeners
            setupDragAndDrop();
            setupEventListeners();
            
            // Start tutorial if first time
            if (playerStats.totalGames === 0) {
                startTutorial();
            }
        }

        // Setup game mode
        function setupGameMode() {
            const mode = DIFFICULTY_LEVELS[currentMode];
            
            // Reset timer
            if (gameTimer) {
                clearInterval(gameTimer);
                gameTimer = null;
            }
            
            if (mode.timeLimit) {
                timeLeft = mode.timeLimit;
                timerElement.style.display = 'block';
                updateTimerDisplay();
                gameTimer = setInterval(() => {
                    timeLeft--;
                    updateTimerDisplay();
                    if (timeLeft <= 0) {
                        endGame();
                    }
                }, 1000);
            } else {
                timerElement.style.display = 'none';
            }
            
            // Update active mode button
            modeButtons.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === currentMode);
            });
        }

        // Generate a random piece
        function generatePiece() {
            // Check for special block
            const specialChance = specialBlockChance + (SKILLS.strategist.getSpecialBlockChance ? SKILLS.strategist.getSpecialBlockChance() : 0);
            if (Math.random() < specialChance) {
                const specialKeys = Object.keys(SPECIAL_BLOCKS);
                const specialKey = specialKeys[Math.floor(Math.random() * specialKeys.length)];
                return { ...SPECIAL_BLOCKS[specialKey], isSpecial: true, specialType: specialKey };
            }
            
            // Regular block
            const shape = JSON.parse(JSON.stringify(BASE_BLOCKS[Math.floor(Math.random() * BASE_BLOCKS.length)]));
            const color = COLORS[Math.floor(Math.random() * COLORS.length)];
            
            // Randomly rotate the piece
            const rotations = Math.floor(Math.random() * 4);
            for (let i = 0; i < rotations; i++) {
                rotatePiece(shape);
            }
            
            return { shape, color, isSpecial: false };
        }

        // Rotate a piece 90 degrees clockwise
        function rotatePiece(shape) {
            const rows = shape.length;
            const cols = shape[0].length;
            const newShape = Array(cols).fill().map(() => Array(rows).fill(0));
            
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    newShape[j][rows - 1 - i] = shape[i][j];
                }
            }
            
            shape.length = 0;
            shape.push(...newShape);
        }

        // Render the game grid
        function renderGrid() {
            gridElement.innerHTML = '';
            const gridSize = DIFFICULTY_LEVELS[currentMode].gridSize;
            
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    
                    if (grid[i][j]) {
                        cell.classList.add('filled', `color-${grid[i][j]}`);
                    }
                    
                    gridElement.appendChild(cell);
                }
            }
        }

        // Render the next pieces preview
        function renderNextPieces() {
            for (let i = 0; i < NEXT_PIECES_COUNT; i++) {
                const pieceElement = document.getElementById(`piece${i+1}`);
                const container = document.getElementById(`pieceContainer${i+1}`);
                pieceElement.innerHTML = '';
                
                if (nextPieces[i]) {
                    const piece = nextPieces[i];
                    const rows = piece.shape.length;
                    const cols = piece.shape[0].length;
                    
                    pieceElement.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
                    pieceElement.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
                    
                    // Add special class for special blocks
                    container.classList.toggle('special', piece.isSpecial);
                    
                    for (let r = 0; r < rows; r++) {
                        for (let c = 0; c < cols; c++) {
                            const cell = document.createElement('div');
                            cell.className = 'piece-cell';
                            
                            if (piece.shape[r][c] === 1) {
                                cell.classList.add(`color-${piece.color}`);
                            } else {
                                cell.style.visibility = 'hidden';
                            }
                            
                            pieceElement.appendChild(cell);
                        }
                    }
                } else {
                    container.classList.remove('special');
                }
            }
        }

        // Render achievements
        function renderAchievements() {
            achievementsList.innerHTML = '';
            Object.keys(ACHIEVEMENTS).forEach(key => {
                const achievement = ACHIEVEMENTS[key];
                const achievementEl = document.createElement('div');
                achievementEl.className = `achievement ${achievement.earned ? 'earned' : ''}`;
                achievementEl.innerHTML = `
                    <div class="achievement-icon">${achievement.icon}</div>
                    <div class="achievement-info">
                        <div class="achievement-name">${achievement.name}</div>
                        <div class="achievement-desc">${achievement.desc}</div>
                        ${achievement.progress !== undefined ? 
                         `<div class="challenge-progress">
                            <div class="challenge-progress-bar" style="width: ${(achievement.progress / achievement.target) * 100}%"></div>
                          </div>` : ''}
                    </div>
                `;
                achievementsList.appendChild(achievementEl);
            });
        }

        // Render challenges
        function renderChallenges() {
            challengesList.innerHTML = '';
            DAILY_CHALLENGES.forEach(challenge => {
                const challengeEl = document.createElement('div');
                challengeEl.className = 'challenge';
                challengeEl.innerHTML = `
                    <div>${challenge.description}</div>
                    <div class="challenge-progress">
                        <div class="challenge-progress-bar" style="width: ${(challenge.current / challenge.target) * 100}%"></div>
                    </div>
                    <small>${challenge.current}/${challenge.target} (+${challenge.reward} –æ—á–∫–æ–≤)</small>
                `;
                challengesList.appendChild(challengeEl);
            });
        }

        // Render skills
        function renderSkills() {
            skillsList.innerHTML = '';
            Object.keys(SKILLS).forEach(key => {
                const skill = SKILLS[key];
                const skillEl = document.createElement('div');
                skillEl.className = 'skill';
                skillEl.innerHTML = `
                    <div class="skill-header">
                        <strong>${skill.name}</strong>
                        <span>–£—Ä. ${skill.level}</span>
                    </div>
                    <div>${skill.effect}</div>
                    <div class="skill-bar">
                        <div class="skill-progress" style="width: ${(skill.exp / skill.expToNext) * 100}%"></div>
                    </div>
                    <small>${skill.exp}/${skill.expToNext} –æ–ø—ã—Ç–∞</small>
                `;
                skillsList.appendChild(skillEl);
            });
        }

        // Update achievement progress
        function updateAchievement(achievementKey, progress) {
            const achievement = ACHIEVEMENTS[achievementKey];
            if (!achievement || achievement.earned) return;
            
            if (achievement.progress !== undefined) {
                achievement.progress = Math.max(achievement.progress, progress);
                if (achievement.progress >= achievement.target) {
                    achievement.earned = true;
                    showFloatingText(`–î–æ—Å—Ç–∏–∂–µ–Ω–∏–µ: ${achievement.name}!`, window.innerWidth/2, window.innerHeight/2, '#ffcc00');
                    audioManager.play('achievement');
                    playerStats.achievementsEarned++;
                }
            } else if (progress) {
                achievement.earned = true;
                showFloatingText(`–î–æ—Å—Ç–∏–∂–µ–Ω–∏–µ: ${achievement.name}!`, window.innerWidth/2, window.innerHeight/2, '#ffcc00');
                audioManager.play('achievement');
                playerStats.achievementsEarned++;
            }
            
            renderAchievements();
        }

        // Update challenge progress
        function updateChallenge(type, amount = 1) {
            DAILY_CHALLENGES.forEach(challenge => {
                if (challenge.type === type) {
                    challenge.current = Math.min(challenge.current + amount, challenge.target);
                    if (challenge.current >= challenge.target) {
                        score += challenge.reward;
                        scoreElement.textContent = score;
                        challenge.current = 0; // Reset for next time
                        showFloatingText(`–ó–∞–¥–∞–Ω–∏–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ! +${challenge.reward}`, window.innerWidth/2, window.innerHeight/2, '#4cd964');
                    }
                }
            });
            renderChallenges();
        }

        // Add skill experience
        function addSkillExp(skillKey, exp) {
            const skill = SKILLS[skillKey];
            if (!skill) return;
            
            skill.exp += exp;
            if (skill.exp >= skill.expToNext) {
                skill.level++;
                skill.exp = 0;
                skill.expToNext = Math.floor(skill.expToNext * 1.5);
                showFloatingText(`${skill.name} —É—Ä–æ–≤–µ–Ω—å ${skill.level}!`, window.innerWidth/2, window.innerHeight/3, '#4a6ee0');
            }
            renderSkills();
        }

        // Setup drag and drop functionality
        function setupDragAndDrop() {
            const pieceContainers = [
                document.getElementById('pieceContainer1'),
                document.getElementById('pieceContainer2'),
                document.getElementById('pieceContainer3')
            ];
            
            pieceContainers.forEach(container => {
                container.replaceWith(container.cloneNode(true));
            });
            
            const newPieceContainers = [
                document.getElementById('pieceContainer1'),
                document.getElementById('pieceContainer2'),
                document.getElementById('pieceContainer3')
            ];
            
            newPieceContainers.forEach((container, index) => {
                container.addEventListener('mousedown', startDrag);
                container.addEventListener('touchstart', startDrag, { passive: false });
                container.dataset.piece = index;
            });
            
            gridElement.addEventListener('mousemove', dragOverGrid);
            gridElement.addEventListener('mouseup', dropOnGrid);
            gridElement.addEventListener('touchmove', dragOverGrid, { passive: false });
            gridElement.addEventListener('touchend', dropOnGrid);
            
            document.addEventListener('mouseup', cancelDrag);
            document.addEventListener('touchend', cancelDrag);
        }

        // Setup event listeners
        function setupEventListeners() {
            restartButton.addEventListener('click', initGame);
            newGameButton.addEventListener('click', initGame);
            rotateButton.addEventListener('click', rotateSelectedPiece);
            hintButton.addEventListener('click', showHint);
            hintBtn.addEventListener('click', showHint);
            soundToggle.addEventListener('click', () => audioManager.toggleMute());
            tutorialNext.addEventListener('click', nextTutorialStep);
            
            modeButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    currentMode = btn.dataset.mode;
                    initGame();
                });
            });
        }

        // Start dragging a piece
        function startDrag(e) {
            if (gameOver) return;
            
            e.preventDefault();
            const pieceIndex = parseInt(e.currentTarget.dataset.piece);
            const piece = nextPieces[pieceIndex];
            
            if (!piece) return;
            
            selectedPieceIndex = pieceIndex;
            createDragGhost(piece, e);
            e.currentTarget.classList.add('piece-dragging');
        }

        // Create drag ghost
        function createDragGhost(piece, e) {
            if (dragGhost) {
                document.body.removeChild(dragGhost);
            }
            
            dragGhost = document.createElement('div');
            dragGhost.className = 'drag-ghost';
            
            const piecePreview = document.createElement('div');
            piecePreview.className = 'piece-preview';
            
            const rows = piece.shape.length;
            const cols = piece.shape[0].length;
            
            piecePreview.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
            piecePreview.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
            
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'piece-cell';
                    
                    if (piece.shape[r][c] === 1) {
                        cell.classList.add(`color-${piece.color}`);
                    } else {
                        cell.style.visibility = 'hidden';
                    }
                    
                    piecePreview.appendChild(cell);
                }
            }
            
            dragGhost.appendChild(piecePreview);
            document.body.appendChild(dragGhost);
            updateDragGhostPosition(e);
        }

        // Update drag ghost position
        function updateDragGhostPosition(e) {
            if (!dragGhost) return;
            
            let clientX, clientY;
            
            if (e.type.includes('touch')) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            
            dragGhost.style.left = `${clientX - dragGhost.offsetWidth / 2}px`;
            dragGhost.style.top = `${clientY - dragGhost.offsetHeight / 2}px`;
        }

        // Handle dragging over grid
        function dragOverGrid(e) {
            if (selectedPieceIndex === null) return;
            
            e.preventDefault();
            updateDragGhostPosition(e);
            
            const cells = gridElement.querySelectorAll('.grid-cell');
            cells.forEach(cell => {
                cell.classList.remove('valid-drop', 'invalid-drop', 'preview');
            });
            
            const cell = document.elementFromPoint(
                e.type.includes('touch') ? e.touches[0].clientX : e.clientX,
                e.type.includes('touch') ? e.touches[0].clientY : e.clientY
            );
            
            if (cell && cell.classList.contains('grid-cell')) {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const piece = nextPieces[selectedPieceIndex];
                
                if (canPlacePiece(piece, col, row)) {
                    showPlacementPreview(piece, col, row);
                    cell.classList.add('valid-drop');
                } else {
                    cell.classList.add('invalid-drop');
                }
            }
        }

        // Show placement preview
        function showPlacementPreview(piece, x, y) {
            for (let i = 0; i < piece.shape.length; i++) {
                for (let j = 0; j < piece.shape[i].length; j++) {
                    if (piece.shape[i][j] === 1) {
                        const cellRow = y + i;
                        const cellCol = x + j;
                        const gridSize = DIFFICULTY_LEVELS[currentMode].gridSize;
                        
                        if (cellRow < gridSize && cellCol < gridSize) {
                            const cell = gridElement.querySelector(`.grid-cell[data-row="${cellRow}"][data-col="${cellCol}"]`);
                            if (cell && !grid[cellRow][cellCol]) {
                                cell.classList.add('preview', `color-${piece.color}`);
                            }
                        }
                    }
                }
            }
        }

        // Drop piece on grid
        function dropOnGrid(e) {
            if (selectedPieceIndex === null) return;
            
            e.preventDefault();
            
            const cell = document.elementFromPoint(
                e.type.includes('touch') ? e.changedTouches[0].clientX : e.clientX,
                e.type.includes('touch') ? e.changedTouches[0].clientY : e.clientY
            );
            
            if (cell && cell.classList.contains('grid-cell')) {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                placePiece(selectedPieceIndex, col, row);
            }
            
            cancelDrag();
        }

        // Cancel drag operation
        function cancelDrag() {
            if (dragGhost) {
                document.body.removeChild(dragGhost);
                dragGhost = null;
            }
            
            const pieceContainers = [
                document.getElementById('pieceContainer1'),
                document.getElementById('pieceContainer2'),
                document.getElementById('pieceContainer3')
            ];
            
            pieceContainers.forEach(container => {
                container.classList.remove('piece-dragging');
            });
            
            const cells = gridElement.querySelectorAll('.grid-cell');
            cells.forEach(cell => {
                cell.classList.remove('valid-drop', 'invalid-drop', 'preview');
            });
            
            selectedPieceIndex = null;
        }

        // Place a piece on the grid
        function placePiece(pieceIndex, x, y) {
            if (gameOver) return false;
            
            const piece = nextPieces[pieceIndex];
            if (!piece) return false;
            
            if (!canPlacePiece(piece, x, y)) {
                return false;
            }
            
            // Place the piece
            let bonusScore = 0;
            for (let i = 0; i < piece.shape.length; i++) {
                for (let j = 0; j < piece.shape[i].length; j++) {
                    if (piece.shape[i][j] === 1) {
                        const gridSize = DIFFICULTY_LEVELS[currentMode].gridSize;
                        if (y + i < gridSize && x + j < gridSize) {
                            grid[y + i][x + j] = piece.color;
                        }
                    }
                }
            }
            
            // Handle special block effects
            if (piece.isSpecial && piece.onPlace) {
                bonusScore = piece.onPlace(x, y, grid);
                if (piece.specialType === 'bomb') {
                    playerStats.specialBlocksUsed++;
                    updateAchievement('bombExpert', playerStats.specialBlocksUsed);
                }
            }
            
            // Remove the placed piece
            nextPieces[pieceIndex] = null;
            blocksPlaced++;
            survivalBlocksPlaced++;
            blocksPlacedElement.textContent = blocksPlaced;
            
            updateAchievement('firstBlood', true);
            updateChallenge('blocks', 1);
            addSkillExp('precision', 10);
            
            // Check for completed lines
            const cleared = clearLines();
            
            if (cleared > 0) {
                const multiplier = comboSystem.startCombo();
                const baseScore = cleared * 100 * multiplier;
                const skillBonus = SKILLS.efficiency.getComboMultiplier ? SKILLS.efficiency.getComboMultiplier(multiplier) : multiplier;
                const finalScore = Math.floor(baseScore * skillBonus) + bonusScore;
                
                score += finalScore;
                scoreElement.textContent = score;
                
                linesCleared += cleared;
                linesClearedElement.textContent = linesCleared;
                
                updateChallenge('rows', cleared);
                updateAchievement('lineMaster', linesCleared);
                addSkillExp('efficiency', cleared * 5);
                
                showFloatingText(`+${finalScore}`, window.innerWidth/2, window.innerHeight/2, '#4cd964');
                audioManager.play('clear');
                
                createParticles(window.innerWidth/2, window.innerHeight/2, '#4cd964', cleared * 5);
            } else {
                comboSystem.resetCombo();
                if (bonusScore > 0) {
                    score += bonusScore;
                    scoreElement.textContent = score;
                    showFloatingText(`+${bonusScore}`, window.innerWidth/2, window.innerHeight/2, '#4a6ee0');
                }
            }
            
            audioManager.play('place');
            
            // Check for level up in survival mode
            if (currentMode === 'survival') {
                checkLevelUp();
            }
            
            // Refill next pieces if all are used
            if (nextPieces.every(piece => piece === null)) {
                for (let i = 0; i < NEXT_PIECES_COUNT; i++) {
                    nextPieces[i] = generatePiece();
                }
            }
            
            // Check for game over
            if (checkGameOver()) {
                endGame();
            }
            
            // Update the display
            renderGrid();
            renderNextPieces();
            
            // Update placement percentage achievement
            const totalCells = Math.pow(DIFFICULTY_LEVELS[currentMode].gridSize, 2);
            const filledCells = grid.flat().filter(cell => cell !== null).length;
            const fillPercentage = Math.round((filledCells / totalCells) * 100);
            updateAchievement('perfectionist', fillPercentage);
            
            return true;
        }

        // Check if a piece can be placed at the given position
        function canPlacePiece(piece, x, y) {
            const gridSize = DIFFICULTY_LEVELS[currentMode].gridSize;
            
            for (let i = 0; i < piece.shape.length; i++) {
                for (let j = 0; j < piece.shape[i].length; j++) {
                    if (piece.shape[i][j] === 1) {
                        if (y + i >= gridSize || x + j >= gridSize || grid[y + i][x + j] !== null) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        // Clear completed lines and update score
        function clearLines() {
            const gridSize = DIFFICULTY_LEVELS[currentMode].gridSize;
            let rowsCleared = 0;
            let colsCleared = 0;
            
            // Check rows
            for (let i = 0; i < gridSize; i++) {
                if (grid[i].every(cell => cell !== null)) {
                    grid[i] = Array(gridSize).fill(null);
                    rowsCleared++;
                    
                    const rowCells = gridElement.querySelectorAll(`.grid-cell[data-row="${i}"]`);
                    rowCells.forEach(cell => {
                        cell.classList.add('clear-animation');
                        setTimeout(() => cell.classList.remove('clear-animation'), 500);
                    });
                }
            }
            
            // Check columns
            for (let j = 0; j < gridSize; j++) {
                let columnFull = true;
                for (let i = 0; i < gridSize; i++) {
                    if (grid[i][j] === null) {
                        columnFull = false;
                        break;
                    }
                }
                
                if (columnFull) {
                    for (let i = 0; i < gridSize; i++) {
                        grid[i][j] = null;
                    }
                    colsCleared++;
                    
                    const colCells = gridElement.querySelectorAll(`.grid-cell[data-col="${j}"]`);
                    colCells.forEach(cell => {
                        cell.classList.add('clear-animation');
                        setTimeout(() => cell.classList.remove('clear-animation'), 500);
                    });
                }
            }
            
            return rowsCleared + colsCleared;
        }

        // Check for level up in survival mode
        function checkLevelUp() {
            if (currentMode === 'survival' && survivalBlocksPlaced >= DIFFICULTY_LEVELS.survival.levelUpBlocks) {
                gameLevel++;
                levelElement.textContent = gameLevel;
                survivalBlocksPlaced = 0;
                
                // Increase difficulty
                specialBlockChance = Math.min(specialBlockChance + 0.05, 0.3);
                
                showFloatingText(`–£—Ä–æ–≤–µ–Ω—å ${gameLevel}!`, window.innerWidth/2, window.innerHeight/3, '#ffcc00');
                audioManager.play('combo');
            }
        }

        // Check if the game is over
        function checkGameOver() {
            for (let piece of nextPieces) {
                if (piece === null) continue;
                
                const gridSize = DIFFICULTY_LEVELS[currentMode].gridSize;
                
                for (let y = 0; y <= gridSize - piece.shape.length; y++) {
                    for (let x = 0; x <= gridSize - piece.shape[0].length; x++) {
                        if (canPlacePiece(piece, x, y)) {
                            return false;
                        }
                    }
                }
            }
            
            return true;
        }

        // End the game
        function endGame() {
            gameOver = true;
            
            if (gameTimer) {
                clearInterval(gameTimer);
            }
            
            finalScoreElement.textContent = score;
            gameOverElement.style.display = 'flex';
            audioManager.play('gameOver');
            
            // Update player stats
            playerStats.updateStats({
                score: score,
                blocksPlaced: blocksPlaced,
                linesCleared: linesCleared,
                maxCombo: maxCombo,
                playTime: timeLeft ? (DIFFICULTY_LEVELS[currentMode].timeLimit - timeLeft) : 0
            });
            
            // Check for speed runner achievement
            if (currentMode === 'time' && score >= 1000) {
                updateAchievement('speedRunner', true);
            }
        }

        // Rotate selected piece
        function rotateSelectedPiece() {
            if (selectedPieceIndex === null) {
                for (let i = 0; i < NEXT_PIECES_COUNT; i++) {
                    if (nextPieces[i]) {
                        selectedPieceIndex = i;
                        break;
                    }
                }
            }
            
            if (selectedPieceIndex !== null && nextPieces[selectedPieceIndex]) {
                rotatePiece(nextPieces[selectedPieceIndex].shape);
                renderNextPieces();
                audioManager.play('rotate');
            }
        }

        // Show hint
        function showHint() {
            const bestPlacement = getBestPlacementHint();
            if (bestPlacement) {
                const { x, y } = bestPlacement;
                const gridSize = DIFFICULTY_LEVELS[currentMode].gridSize;
                const cellSize = gridElement.offsetWidth / gridSize;
                const hintX = x * cellSize + cellSize / 2;
                const hintY = y * cellSize + cellSize / 2;
                
                createParticles(hintX, hintY, '#ffcc00', 20);
                showFloatingText('üëÜ', hintX, hintY, '#ffcc00');
            }
        }

        // Get best placement hint
        function getBestPlacementHint() {
            let bestScore = -1;
            let bestPlacement = null;
            const gridSize = DIFFICULTY_LEVELS[currentMode].gridSize;
            
            nextPieces.forEach((piece, pieceIndex) => {
                if (!piece) return;
                
                for (let y = 0; y <= gridSize - piece.shape.length; y++) {
                    for (let x = 0; x <= gridSize - piece.shape[0].length; x++) {
                        if (canPlacePiece(piece, x, y)) {
                            const score = calculatePlacementScore(piece, x, y);
                            if (score > bestScore) {
                                bestScore = score;
                                bestPlacement = { pieceIndex, x, y, score };
                            }
                        }
                    }
                }
            });
            
            return bestPlacement;
        }

        // Calculate placement score
        function calculatePlacementScore(piece, x, y) {
            let score = 0;
            const gridSize = DIFFICULTY_LEVELS[currentMode].gridSize;
            
            // Simulate placement
            const tempGrid = JSON.parse(JSON.stringify(grid));
            for (let i = 0; i < piece.shape.length; i++) {
                for (let j = 0; j < piece.shape[i].length; j++) {
                    if (piece.shape[i][j] === 1) {
                        tempGrid[y + i][x + j] = piece.color;
                    }
                }
            }
            
            // Check for potential lines
            for (let i = 0; i < gridSize; i++) {
                if (tempGrid[i].every(cell => cell !== null)) score += 100;
            }
            
            for (let j = 0; j < gridSize; j++) {
                let full = true;
                for (let i = 0; i < gridSize; i++) {
                    if (tempGrid[i][j] === null) {
                        full = false;
                        break;
                    }
                }
                if (full) score += 100;
            }
            
            // Bonus for special blocks
            if (piece.isSpecial) score += 50;
            
            return score;
        }

        // Update timer display
        function updateTimerDisplay() {
            const minutes = Math.floor(timeLeft / 60);
            const seconds = timeLeft % 60;
            timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            if (timeLeft <= 10) {
                timerElement.style.color = '#ff3b30';
            } else if (timeLeft <= 30) {
                timerElement.style.color = '#ff9500';
            } else {
                timerElement.style.color = '#ffcc00';
            }
        }

        // Create particles effect
        function createParticles(x, y, color, count = 10) {
            for (let i = 0; i < count; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.backgroundColor = color;
                particle.style.left = x + 'px';
                particle.style.top = y + 'px';
                
                document.body.appendChild(particle);
                
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 3;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;
                
                let posX = x;
                let posY = y;
                
                function animate() {
                    posX += vx;
                    posY += vy;
                    particle.style.left = posX + 'px';
                    particle.style.top = posY + 'px';
                    particle.style.opacity = parseFloat(particle.style.opacity || 1) - 0.02;
                    
                    if (parseFloat(particle.style.opacity) > 0) {
                        requestAnimationFrame(animate);
                    } else {
                        document.body.removeChild(particle);
                    }
                }
                
                animate();
            }
        }

        // Show floating text
        function showFloatingText(text, x, y, color = '#ffcc00') {
            const floatingText = document.createElement('div');
            floatingText.className = 'floating-text';
            floatingText.textContent = text;
            floatingText.style.color = color;
            floatingText.style.left = x + 'px';
            floatingText.style.top = y + 'px';
            
            document.body.appendChild(floatingText);
            
            setTimeout(() => {
                document.body.removeChild(floatingText);
            }, 1000);
        }

        // Start tutorial
        function startTutorial() {
            tutorialStep = 0;
            showTutorialStep();
        }

        // Show tutorial step
        function showTutorialStep() {
            if (tutorialStep >= TUTORIAL_STEPS.length) {
                tutorialOverlay.style.display = 'none';
                return;
            }
            
            const step = TUTORIAL_STEPS[tutorialStep];
            tutorialTitle.textContent = step.title;
            tutorialText.textContent = step.text;
            tutorialOverlay.style.display = 'flex';
        }

        // Next tutorial step
        function nextTutorialStep() {
            tutorialStep++;
            showTutorialStep();
        }

        // Initialize the game when the page loads
        window.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>